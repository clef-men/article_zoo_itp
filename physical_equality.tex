\section{Physical equality}
\label{sec:physical_equality}

\input{figures/rcfd}

The notion of \emph{physical equality} is ubiquitous in fine-grained concurrent algorithms.
It appears not only in the semantics of the \mintinline{ocaml}{==} operator, but also in the semantics of the \mintinline{ocaml}{Atomic.compare_and_set} primitive, which atomically sets an atomic reference to a desired value if its current content is physically equal to an expected value.
This primitive is commonly used to try committing an atomic operation in a retry loop, as in the \texttt{push} and \texttt{pop} functions of \cref{fig:stack}.

In \HeapLang, this primitive is provided but restricted.
Indeed, its semantics is only defined if either the expected or the desired value fits in a single memory word in the \HeapLang value representation: literals (booleans, integers and pointers\footnote{\HeapLang allows arbitrary pointer arithmetic and therefore inner pointers. This is forbidden in both \OCaml and \ZooLang, as any reachable value has to be compatible with the garbage collector.}) and literal injections\footnote{\HeapLang has no primitive notion of constructor, only pairs and injections (left and right).}; otherwise, the program is stuck.
\Xgabriel[In practice, this restriction forces the programmer to introduce an indirection~\cite{iris/examples,DBLP:conf/cpp/VindumB21} to physically compare complex values, \eg lists.]{I don't understand this well: in OCaml as well, cons-cells are represented by ``an indirection'' (a pointer to a block with the head and tail), what is the difference here? I think that you are making a subtle distinction because you think of the ``value'' of mutable blocks as their pointer (as in OCaml), but the ``value'' of immutable as something else (whereas OCaml programmers would typically think of the pointer as well). This should be explained, otherwise what you say here is fairly confusing.}
Furthermore, when the semantics is defined, values are compared using their \Rocq representations; physical equality boils down to \Rocq equality.

In \OCaml, physical equality is more tricky and often considered dangerous.
\emph{Structural equality}, which we describe in \cref{sec:structural_equality}, should be the preferred way of comparing values.
However, structural equality is typically much slower than physical equality, as it basically compiles to only one assembly instruction.
Also, the \mintinline{ocaml}{Atomic.compare_and_set} requires the comparison to be atomic, which is the case for physical equality but not structural equality.

In particular, the semantics of physical equality is \emph{non-deterministic}.
\Xgabriel{Non-deterministic on high-level values, not on low-level values. Again, omitting this distinction here makes the story hard to understand and potentially confusing.}
To see why, consider the case of \emph{immutable blocks} representing constructors and immutable records (as opposed to \emph{mutable blocks} representing mutable records), \eg \mintinline{ocaml}{Some 0}.
The physical comparison of two seemingly identical immutable blocks, according to the \Rocq representation (essentially a tag and a list of fields), may return \mintinline{ocaml}{false}.
Indeed, at runtime, a non-empty immutable block is represented by a pointer to a tagged memory block.
In this case, physical equality is just pointer comparison.
It is clear that two pointers being distinct does not imply the pointed memory blocks are.
In other words, we cannot determine the result of physical comparison just by looking at the abstract values.

The question is then: what guarantees do we get when physical equality returns \mintinline{ocaml}{true} and when it returns \mintinline{ocaml}{false}?
Unfortunately, the only guarantee that \OCaml \Xgabriel[provides]{\emph{documents}} is: if two values are physically equal, they are also structurally equal.
This means we don't learn anything when two values are physically distinct.
\Xgabriel{We provide more guarantees on mutable values. You are implicitly talking about immutable constructors here.}

In the following, we will explore both cases, looking at the optimizations that the compiler or the runtime system may perform.
We will show that the aforementioned guarantee is arguably not sufficient to verify interesting concurrent programs and attempt to establish stronger guarantees.

\subsection{When physical equality returns \mintinline{ocaml}{true}}

Let us go back to the concurrent stack of \cref{fig:stack} and more specifically the \mintinline{ocaml}{push} function.
To prove the atomic specification given in \cref{sec:zoo}, we rely on the fact that, if \mintinline{ocaml}{Atomic.compare_and_set} returns \mintinline{ocaml}{true}, we actually observe the same list of values in the sense of \Rocq equality.
But this specification cannot be proven if we only assume, on immutable blocks such as lists, that physical equality implies structural equality: given two lists of references, if we learn that they are (structurally) equal, we cannot conclude that their references are the same.

This conclusion might seem surprising and counterintuitive.
Indeed, we know that physical equality essentially boils down to a comparison instruction, so we should be able to say more.
Departing from \OCaml's imprecise specification, let us attempt to establish stronger guarantees.
We assume the following classification of values: booleans, integers, mutable blocks (pointers), immutable blocks, functions.

The easy cases are mutable blocks and functions.
Each of these two classes is disjoint from the others.
We can reasonably assume that, when physical equality returns \mintinline{ocaml}{true} and one of the compared values belongs to either of these classes, the two values are actually the same in \Rocq.
As far as we are aware, there is no optimization that could break this.

Booleans, integers and empty immutable blocks are represented by immediate integers through an encoding.
This encoding induces conflicts: two seemingly distinct values in \Rocq may have the same encoding.
For example, the following tests all return \mintinline{ocaml}{true} (\mintinline{ocaml}{Obj.repr} is an unsafe primitive revealing the memory representation of a value):

\Xgabriel{I would rather show the tests with the existential GADT, which do not require the Obj module and are more arguably ``valid OCaml''.}
\begin{minted}{ocaml}
let test1 = Obj.repr false == Obj.repr 0 (* true *)
let test2 = Obj.repr None  == Obj.repr 0 (* true *)
let test3 = Obj.repr []    == Obj.repr 0 (* true *)
\end{minted}

The semantics of unrestricted physical equality has to reflect these conflicts.
In our experience, restricting compared values similarly to typing is quite burdensome; the specification of polymorphic data structures using physical equality has to be systematically restricted.
In summary, when physical equality on immediate values returns \mintinline{ocaml}{true}, it is guaranteed that they have the same encoding.

Finally, let us consider the case of non-empty immutable blocks.
At runtime, they are represented by pointers to tagged memory blocks.
At first approximation, it is tempting to say that physically equal immutable blocks really are the same in \Rocq.
Alas, this is not true.
To explain why, we have to recall that the \OCaml compiler and the runtime system (\eg, through hash-consing) may perform \emph{sharing}: immutable blocks containing physically equal fields may be shared.
For example, the following tests may return \mintinline{ocaml}{true}:

\begin{minted}{ocaml}
let test1 = Some 0 == Some 0 (* true *)
let test2 = [0;1]  == [0;1]  (* true *)
\end{minted}

On its own, sharing is not a problem.
However, coupled with representation conflicts, it can be surprising.
Indeed, consider the \mintinline{ocaml}{any} type defined as:

\begin{minted}{ocaml}
type any = Any : 'a -> any
\end{minted}

The following tests may return \mintinline{ocaml}{true}:

\begin{minted}{ocaml}
let test1 = Any false == Any 0 (* true *)
let test2 = Any None  == Any 0 (* true *)
let test3 = Any []    == Any 0 (* true *)
\end{minted}

Now, going back to the \texttt{push} function of \cref{fig:stack}, we have a problem.
Given a stack of \mintinline{ocaml}{any}, it is possible for the \mintinline{ocaml}{Atomic.compare_and_set} to observe a current list (\eg, \mintinline{ocaml}{[Any 0]}) physically equal to the expected list (\eg, \mintinline{ocaml}{[Any false]}) while these are actually distinct in \Rocq.
In short, the expected specification of \cref{sec:zoo} is incorrect.
To fix it, we would need to reason \emph{modulo physically equality}, which is non-standard and quite burdensome.

We believe this really is a shortcoming, at least from the verification perspective.
Therefore, we propose to extend \OCaml with \emph{generative immutable blocks}\footnote{\urlAnonymous{https://github.com/clef-men/ocaml/tree/generative_constructors}}.
These generative blocks are just like regular immutable blocks, except they cannot be shared.
Hence, if physical equality on two generative blocks returns \mintinline{ocaml}{true}, these blocks are necessarily equal in \Rocq.
At user level, this notion is materialized by \emph{generative constructors}.
For instance, to verify the expected \texttt{push} specification, we can use a generative version of lists:

\begin{minted}{ocaml}
type 'a list =
  | Nil
  | Cons of 'a * 'a list [@generative]
\end{minted}

\subsection{When physical equality returns \mintinline{ocaml}{false}}

The informal \OCaml specification does not give any guarantee when physical equality returns \mintinline{ocaml}{false}.
In most cases, including try loops, this is fine.
However, in some specific cases, more information is needed.

Consider the \mintinline{ocaml}{Rcfd} module from the \Eio~\cite{eio} library, an excerpt of which is given in \cref{fig:rcfd}.
Thomas Leonard, its author, suggested that we verify this real-life example because of its intricate logical state.
However, we found out that it is also relevant regarding the semantics of physical equality.
Essentially, it consists in wrapping a file descriptor in a thread-safe way using reference-counting.

%Essentially, it consists in protecting a file descriptor using reference counting.
%Similarly, it relies on atomically updating the \mintinline{ocaml}{state} field using \mintinline{ocaml}{Atomic.Loc.compare_and_set}\footnote{Here, we make use of atomic record fields as we propose them for \OCaml, see Section~\ref{sec:atomic-record-fields}.}.
%However, there is a complication.
%Indeed, we claim that the correctness of \mintinline{ocaml}{close} derives from the fact that the \mintinline{ocaml}{Open} state does not change throughout the lifetime of the data structure; it can be replaced by a \mintinline{ocaml}{Closing} state but never by another \mintinline{ocaml}{Open}.
%In other words, we want to say that 1) this \mintinline{ocaml}{Open} is \emph{physically unique} and 2) \mintinline{ocaml}{Atomic.Loc.compare_and_set} therefore detects whether the data structure has flipped into the \mintinline{ocaml}{Closing} state.
%In fact, this kind of property appears frequently in lock-free algorithms; it also occurs in the \Kcas~\cite{kcas} library\footnote{\url{https://github.com/ocaml-multicore/kcas/blob/main/doc/gkmz-with-read-only-cmp-ops.md}}.
%
%Once again, this argument requires special care in the semantics of physical equality.
%In short, we have to reveal something about the physical identity of some abstract values.
%Yet, we cannot reveal too much---in particular, we cannot simply convert an abstract value to a concrete one (a memory location)---, since the \OCaml compiler performs optimizations like sharing of immutable constants, and the semantics should remain compatible with adding other optimizations later on, such as forms of hash-consing.


%If physical comparison returns \mintinline{ocaml}{false}, the semantics of \OCaml tells us essentially nothing: two immutable blocks may have distinct identities but same content.
%However, given this semantics, we cannot verify the \mintinline{ocaml}{Rcfd} example of \cref{sec:introduction}.
%To see why, consider the first \mintinline{ocaml}{Atomic.compare_and_set} in the \mintinline{ocaml}{close} function.
%If it fails, we expect to see a \mintinline{ocaml}{Closing} state because we know there is only one \mintinline{ocaml}{Open} state ever created, but we cannot prove it.
%To address it, we take another step back from \OCaml's semantics by introducing the \texttt{Reveal} construct.
%When applied to an immutable memory block, \texttt{Reveal} yields the same block annotated with a logical identifier that can be interpreted as its abstract identity.
%The meaning of this identifier is: if physical comparison of two identified blocks returns \mintinline{ocaml}{false}, the two identifiers are necessarily distinct.
%The underling assumption that we make here---which is hopefully also correct in the current implementation of \OCaml---is that the compiler may introduce sharing but not unsharing.
%
%The introduction of \texttt{Reveal} can be performed automatically by \texttt{ocaml2zoo} provided the user annotates the data constructor (\eg \mintinline{ocaml}{Open}) with the attribute \mintinline{ocaml}{[@zoo.reveal]}.
%For \mintinline{ocaml}{Rcfd.make}, it generates:
%
%\begin{minted}{coq}
%Definition rcfd_make : val :=
%  fun: "fd" =>
%    { #0, Reveal ‘Open( "fd" ) }.
%\end{minted}
%
%Given this semantics and having revealed the \mintinline{ocaml}{Open} block, we can verify the \mintinline{ocaml}{close} function.
%Indeed, if the first \mintinline{ocaml}{Atomic.compare_and_set} fails, we now know that the identifiers of the two blocks, if any, are distinct.
%As there is only one \mintinline{ocaml}{Open} block whose identifier does not change, it cannot be the case that the current state is \mintinline{ocaml}{Open}, hence it is \mintinline{ocaml}{Closing} and we can conclude.

\section{Physical equality -- alternative proposal}

The notion of \emph{physical equality} is ubiquitous in fine-grained concurrent algorithms.
It appears not only in the semantics of the \mintinline{ocaml}{==} operator, but also in the semantics of the \mintinline{ocaml}{Atomic.compare_and_set} primitive, which atomically sets an atomic reference to a desired value if its current content is physically equal to an expected value.
This primitive is commonly used to try committing an atomic operation in a retry loop, as in the \texttt{push} and \texttt{pop} functions of \cref{fig:stack}.

At the same time this notion is difficult to specify correctly, and this can result in dangerous gaps between the programming language used to write code and the semantics used for its verification.

\ZooLang has a grammar of values, and most operations are specified by defining how they compute with \ZooLang values. Its definition may look as follows in Rocq (simplified slightly):
\begin{minted}{coq}
Inductive literal :=
  | Bool (b : bool)
  | Int (n : nat)
  | Loc (l : location)
  | Proph (pid : prophet_id)
  | Poison.

Inductive val :=
  | Lit (lit : literal)
  | Recs (i : nat) (recs : list (binder * binder * expr))
  | Block (tag : nat) (vs : list val).
\end{minted}

For example, the value $'\texttt{Cons} (42, \texttt{§}\texttt{Nil})$ is represented in Rocq as \mintinline{coq}{Block 1 [Lit (Int 42), Block 0 []]}. Notice that immutable blocks are represented in Rocq using the \mintinline{coq}{Block} constructor directly, and \emph{not} as a location (\mintinline{coq}{Loc}) allocated on the heap. We use locations only for \emph{mutable} records. We would say that our representation of \ZooLang values is \emph{high-level}, as close to the surface syntax as reasonably possible. This distinction is important to make verification pleasant in practice, by reducing the number of locations and heap indirections that the programmer needs to work with during verification. A \ZooLang tuple is directly a tuple, etc., and this design decision of using high-level values is important to the verification experience.
\Xclement{Not only that, but assuming full ownership of arguments of immutable blocks would be incorrect.}

It is tempting to specify, as \HeapLang does, that physical equality decides equality between high-level values. This specification makes sense for immediate values (integers, booleans), and for mutable records which are compared by location. But it is incorrect on immutable blocks, and \HeapLang essentially does not specify its behavior on those values. Yet programmers use physical equality on immutable blocks in practice, as in our example of a Treiber stack of \cref{fig:stack}.

Defining physical equality as equality of high-level values is problematic in two opposite ways:
\begin{enumerate}
\item Some distinct high-level values are physically equal in OCaml, for example \mintinline{ocaml}{0} and \mintinline{ocaml}{false}. Their type differ, but it possible to store them in an existential type where they can be compared for physical equality:
\begin{minted}{ocaml}
type any = Any : 'a -> any
let test1 = Any false == Any 0 (* true *)
\end{minted}
This shows that even on immediate values, specifying physical equality as equality of high-level values is convenient but incorrect in practice.

\item A deeper problem is that some \emph{definitionally equal} high-level values may be physically distinct.
  For example, if \mintinline{ocaml}{x} is defined as the integer \mintinline{ocaml}{42}, then \mintinline{ocaml}{(x :: []) == (42 :: [])} may or may not  hold, depending on the OCaml implementation being used.
  But one can prove that both arguments are definitionally equal in Rocq, so physical equality cannot be modeled by a Rocq function of type \mintinline{coq}{val -> val -> bool}.
\end{enumerate}

\Xgabriel{TODO: specifying this carefully gives a predicate on high-level values that is non-deterministic.}
