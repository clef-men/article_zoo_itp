\section{Physical equality}
\label{sec:physical_equality}

\input{figures/rcfd}

\paragraph{Example 1: physical equality.}

Consider, for example, the \OCaml implementation of a concurrent stack~\cite{thomas1986systems} in \cref{fig:stack}.
Essentially, it consists of an atomic reference to a list that is updated atomically using the \mintinline{ocaml}{Atomic.compare_and_set} primitive.
While this simple implementation---it is indeed one of the simplest lock-free algorithms---may seem easy to verify, it is actually more subtle than it looks.

Indeed, the semantics of \mintinline{ocaml}{Atomic.compare_and_set} involves \emph{physical equality}: if the content of the atomic reference is physically equal to the expected value, it is atomically updated to the new value.
Comparing physical equality is tricky and can be dangerous---this is why \emph{structural equality} is often preferred---because the programmer has few guarantees about the \emph{physical identity} of a value.
In particular, the physical identity of a list, or more generally of an inhabitant of an algebraic data type, is not really specified.
The only guarantee is: if two values are physically equal, they are also structurally equal.
Apparently, we don't learn anything interesting when two values are physically distinct.
Going back to our example, this is fortunately not an issue, since we always retry the operation when \mintinline{ocaml}{Atomic.compare_and_set} returns \mintinline{ocaml}{false}.

Looking at the standard runtime representation of \OCaml values, this makes sense.
The empty list is represented by a constant while a non-empty list is represented by pointer to a tagged memory block.
Physical equality for non-empty lists is just pointer comparison.
It is clear that two pointers being distinct does not imply the pointed memory blocks are.

From the viewpoint of formal verification, this means we have to carefully design the semantics of the language to be able to reason about physical equality and other subtleties of concurrent programs.
Essentially, the conclusion we can draw is that the semantics of physical equality and therefore \mintinline{ocaml}{Atomic.compare_and_set} is non-deterministic: we cannot determine the result of physical comparison just by looking at the abstract values.

\paragraph{Example 2: when physical identity matters.}

Consider another example given in \cref{fig:rcfd}: the \mintinline{ocaml}{Rcfd.close}\footnote{\url{https://github.com/ocaml-multicore/eio/blob/main/lib_eio/unix/rcfd.ml}} function from the \Eio~\cite{eio} library.
Essentially, it consists in protecting a file descriptor using reference counting.
Similarly, it relies on atomically updating the \mintinline{ocaml}{state} field using \mintinline{ocaml}{Atomic.Loc.compare_and_set}\footnote{Here, we make use of atomic record fields that were \href{https://github.com/ocaml/ocaml/pull/13404}{recently introduced} in \OCaml.}.
However, there is a complication.
Indeed, we claim that the correctness of \mintinline{ocaml}{close} derives from the fact that the \mintinline{ocaml}{Open} state does not change throughout the lifetime of the data structure; it can be replaced by a \mintinline{ocaml}{Closing} state but never by another \mintinline{ocaml}{Open}.
In other words, we want to say that 1) this \mintinline{ocaml}{Open} is \emph{physically unique} and 2) \mintinline{ocaml}{Atomic.Loc.compare_and_set} therefore detects whether the data structure has flipped into the \mintinline{ocaml}{Closing} state.
In fact, this kind of property appears frequently in lock-free algorithms; it also occurs in the \Kcas~\cite{kcas} library\footnote{\url{https://github.com/ocaml-multicore/kcas/blob/main/doc/gkmz-with-read-only-cmp-ops.md}}.

Once again, this argument requires special care in the semantics of physical equality.
In short, we have to reveal something about the physical identity of some abstract values.
Yet, we cannot reveal too much---in particular, we cannot simply convert an abstract value to a concrete one (a memory location)---, since the \OCaml compiler performs optimizations like sharing of immutable constants, and the semantics should remain compatible with adding other optimizations later on, such as forms of hash-consing.

% ----------------------

In \Zoo, a value is either a bool, an integer, a memory location, a function or an immutable block.
To deal with physical equality in the semantics, we have to specify what guarantees we get when 1) physical comparison returns \mintinline{ocaml}{true} and 2) when it returns \mintinline{ocaml}{false}.

We assume that the program is semantically well typed, if not syntactically well typed, in the sense that compared values are loosely compatible: a boolean may be compared with another boolean or a location, an integer may be compared with another integer or a location, an immutable block may be compared with another immutable block or a location.
This means we never physically compare, \eg, a boolean and an integer, an integer and an immutable block.
If we wanted to allow it, we would have to extend the semantics of physical comparison to account for conflicts in the memory representation of values.

For booleans, integers and memory locations, the semantics of physical equality is plain equality.
Let us consider the case of abstract values (functions and immutable blocks).

If physical comparison returns \mintinline{ocaml}{true}, the semantics of \OCaml tells us that these values are structurally equal.
This is very weak because structural equality for memory locations is not plain equality.
In fact, assuming only that, the stack of \cref{sec:introduction} and many other concurrent algorithms relying on physical equality would be incorrect.
Indeed, for \eg a stack of references (\mintinline{ocaml}{'a ref}), a successful \mintinline{ocaml}{Atomic.compare_and_set} in \mintinline{ocaml}{push} or \mintinline{ocaml}{pop} would not be guaranteed to have seen the exact same list of references; the expected specification of \cref{sec:zoo} would not work.
What we want and what we assume in our semantics is plain equality.
Hopefully, this should be correct in practice, as we know physical equality is implemented as plain comparison.

If physical comparison returns \mintinline{ocaml}{false}, the semantics of \OCaml tells us essentially nothing: two immutable blocks may have distinct identities but same content.
However, given this semantics, we cannot verify the \mintinline{ocaml}{Rcfd} example of \cref{sec:introduction}.
To see why, consider the first \mintinline{ocaml}{Atomic.compare_and_set} in the \mintinline{ocaml}{close} function.
If it fails, we expect to see a \mintinline{ocaml}{Closing} state because we know there is only one \mintinline{ocaml}{Open} state ever created, but we cannot prove it.
To address it, we take another step back from \OCaml's semantics by introducing the \texttt{Reveal} construct.
When applied to an immutable memory block, \texttt{Reveal} yields the same block annotated with a logical identifier that can be interpreted as its abstract identity.
The meaning of this identifier is: if physical comparison of two identified blocks returns \mintinline{ocaml}{false}, the two identifiers are necessarily distinct.
The underling assumption that we make here---which is hopefully also correct in the current implementation of \OCaml---is that the compiler may introduce sharing but not unsharing.

The introduction of \texttt{Reveal} can be performed automatically by \texttt{ocaml2zoo} provided the user annotates the data constructor (\eg \mintinline{ocaml}{Open}) with the attribute \mintinline{ocaml}{[@zoo.reveal]}.
For \mintinline{ocaml}{Rcfd.make}, it generates:

\begin{minted}{coq}
Definition rcfd_make : val :=
  fun: "fd" =>
    { #0, Reveal â€˜Open( "fd" ) }.
\end{minted}

Given this semantics and having revealed the \mintinline{ocaml}{Open} block, we can verify the \mintinline{ocaml}{close} function.
Indeed, if the first \mintinline{ocaml}{Atomic.compare_and_set} fails, we now know that the identifiers of the two blocks, if any, are distinct.
As there is only one \mintinline{ocaml}{Open} block whose identifier does not change, it cannot be the case that the current state is \mintinline{ocaml}{Open}, hence it is \mintinline{ocaml}{Closing} and we can conclude.